# floodfill_main.py — WORKING WITH YOUR ROBOT

import time
import encoders

from sensors import read_left, read_right, read_front
from motors import stop
from turns import turn_left, turn_right
from pid import drive_straight_sensor_once


# ============================================================
# MAZE CONSTANTS
# ============================================================
MAZE_SIZE = 12     # 12x12 micromouse maze

DIR_NORTH = 0
DIR_EAST  = 1
DIR_SOUTH = 2
DIR_WEST  = 3

mouse_x = 0
mouse_y = 0
heading = DIR_NORTH


# ============================================================
# MOVEMENT / SENSOR PARAMETERS FOR YOUR ROBOT
# ============================================================
WALL_DETECTION_MM = 85
CELL_TRAVEL_MS    = 1400     # ROBOT forward time for 1 full cell using PID
TURN_EXTRA_MS     = 200      # forward after turning

# You measured these:
COUNTS_PER_CELL   = 180      # For mapping only, not control.
MOVE_SPEED        = 22       # Not used anymore (PID is used)


# ============================================================
# MAPS
# ============================================================
distance_grid = [[255 for _ in range(MAZE_SIZE)] for _ in range(MAZE_SIZE)]
wall_grid     = [[0   for _ in range(MAZE_SIZE)] for _ in range(MAZE_SIZE)]


# ============================================================
# GOAL AREA (center 2×2)
# ============================================================
def is_goal_cell(x, y):
    return (x in (5, 6)) and (y in (5, 6))


def at_goal():
    return is_goal_cell(mouse_x, mouse_y)


# ============================================================
# INITIALIZATION
# ============================================================
def setup_distances():
    for x in range(MAZE_SIZE):
        for y in range(MAZE_SIZE):
            distance_grid[x][y] = 255

    distance_grid[5][5] = 0
    distance_grid[5][6] = 0
    distance_grid[6][5] = 0
    distance_grid[6][6] = 0


def setup_outer_walls():
    for i in range(MAZE_SIZE):
        wall_grid[i][0] |=  (1 << DIR_SOUTH)
        wall_grid[i][MAZE_SIZE - 1] |= (1 << DIR_NORTH)
        wall_grid[0][i] |=  (1 << DIR_WEST)
        wall_grid[MAZE_SIZE - 1][i] |= (1 << DIR_EAST)


# ============================================================
# WALL HANDLING
# ============================================================
def add_wall(x, y, direction):
    global wall_grid
    wall_grid[x][y] |= (1 << direction)

    nx, ny = x, y

    if direction == DIR_WEST:  nx -= 1
    if direction == DIR_EAST:  nx += 1
    if direction == DIR_NORTH: ny += 1
    if direction == DIR_SOUTH: ny -= 1

    if 0 <= nx < MAZE_SIZE and 0 <= ny < MAZE_SIZE:
        opposite = (direction + 2) & 0x3
        wall_grid[nx][ny] |= (1 << opposite)


def update_walls_from_measurement(d_left, d_front, d_right):
    global mouse_x, mouse_y, heading

    x, y = mouse_x, mouse_y

    front = heading
    left  = (heading + 3) & 3
    right = (heading + 1) & 3

    if 0 < d_front < WALL_DETECTION_MM:
        add_wall(x, y, front)

    if 0 < d_left < WALL_DETECTION_MM:
        add_wall(x, y, left)

    if 0 < d_right < WALL_DETECTION_MM:
        add_wall(x, y, right)


# ============================================================
# FLOOD-FILL UPDATE
# ============================================================
def recompute_floodfill():
    changed = True

    while changed:
        changed = False

        for x in range(MAZE_SIZE):
            for y in range(MAZE_SIZE):

                if is_goal_cell(x, y):
                    continue

                best = 255

                if not (wall_grid[x][y] & (1 << DIR_WEST))  and x > 0:
                    best = min(best, distance_grid[x - 1][y])

                if not (wall_grid[x][y] & (1 << DIR_NORTH)) and y < MAZE_SIZE - 1:
                    best = min(best, distance_grid[x][y + 1])

                if not (wall_grid[x][y] & (1 << DIR_EAST))  and x < MAZE_SIZE - 1:
                    best = min(best, distance_grid[x + 1][y])

                if not (wall_grid[x][y] & (1 << DIR_SOUTH)) and y > 0:
                    best = min(best, distance_grid[x][y - 1])

                new_value = best + 1

                if new_value != distance_grid[x][y]:
                    distance_grid[x][y] = new_value
                    changed = True


# ============================================================
# SELECT NEXT DIRECTION BASED ON FLOOD-FILL
# ============================================================
def select_next_direction():
    global mouse_x, mouse_y

    x, y = mouse_x, mouse_y

    best_dir = None
    best_val = 255

    for direction in (DIR_NORTH, DIR_EAST, DIR_SOUTH, DIR_WEST):
        if wall_grid[x][y] & (1 << direction):
            continue

        nx, ny = x, y

        if direction == DIR_WEST:  nx -= 1
        if direction == DIR_EAST:  nx += 1
        if direction == DIR_NORTH: ny += 1
        if direction == DIR_SOUTH: ny -= 1

        if 0 <= nx < MAZE_SIZE and 0 <= ny < MAZE_SIZE:
            if distance_grid[nx][ny] < best_val:
                best_val = distance_grid[nx][ny]
                best_dir = direction

    return best_dir


# ============================================================
# MOVEMENT (REAL ROBOT VERSION)
# ============================================================
def move_one_cell(target_direction):
    global mouse_x, mouse_y, heading

    if target_direction is None:
        stop()
        return

    diff = (target_direction - heading) & 3

    if diff == 1:
        turn_right()
        time.sleep_ms(TURN_EXTRA_MS)

    elif diff == 2:
        turn_right()
        time.sleep_ms(150)
        turn_right()
        time.sleep_ms(TURN_EXTRA_MS)

    elif diff == 3:
        turn_left()
        time.sleep_ms(TURN_EXTRA_MS)

    heading = target_direction

    # Move forward 1 full maze cell using PID
    drive_straight_sensor_once(CELL_TRAVEL_MS)

    # Update robot coordinates
    if heading == DIR_NORTH: mouse_y += 1
    if heading == DIR_SOUTH: mouse_y -= 1
    if heading == DIR_EAST:  mouse_x += 1
    if heading == DIR_WEST:  mouse_x -= 1


# ============================================================
# MAIN FLOOD-FILL LOOP
# ============================================================
def main():
    global heading, mouse_x, mouse_y

    print("\n=== FLOOD-FILL MICROMOUSE (REAL ROBOT VERSION) ===\n")

    setup_outer_walls()
    setup_distances()

    if hasattr(encoders, "setup"):
        encoders.setup()
    encoders.reset()

    while not at_goal():

        # 1. Read sensors
        dL = read_left()
        dR = read_right()
        dF = read_front()

        # 2. Update maze wall map
        update_walls_from_measurement(dL, dF, dR)

        # 3. Recompute shortest distances
        recompute_floodfill()

        # 4. Choose next direction
        next_dir = select_next_direction()

        # 5. Move into the next cell
        move_one_cell(next_dir)

        time.sleep(0.05)

    stop()
    print("Reached the GOAL at cell:", mouse_x, mouse_y)


# ============================================================
if __name__ == "__main__":
    main()

